%!TEX root = ../Main.tex
\section{Related Work}

In future work would be interesting to implement a system to take a data flow graph without a polarity assignment, and assign polarities to the combinators such that the entire graph can be executed without buffering (if possible). However, so far the largest programs we have written using the library have included only 10-15 combinators in a single function, and so far assigning the polarities has not been a burden. 

In practice there is usually a natural distinction between the \emph{input network} written using sources and the \emph{output network} using sinks, and hybrid combinators such as @dup_iio@ are used infrequently.

\begin{itemize}
\item Iteratee~\cite{Kiselyov:iteratee}
\item Enumerator~\cite{hackage:enumerator}
\item Conduit~\cite{hackage:conduit}, we don't have await and yield. Flows are not monad transformers.
\item Pipes~\cite{hackage:pipes}
\item Machines~\cite{hackage:machines} support multiple inputs and fanout.
\item Monad par, is event flow network using IVars.
\item Spark~\cite{Zaharia:RDDs}.
\item Google Tensorflow
\item Lucy~\cite{Mandel:Lucy}.
\item On the polarity of pipelines~\cite{Kay:YouPull}.
\item Kahn networks.
\item StreamIt, Brook.
\item Scalaz streams library~\cite{github:scalaz-streams}
\item FRP libraries, eg reflex.
\item Obsidian~\cite{Claessen:ExpressiveArray}.
\item Composable Efficient Array Computations~\cite{Bernardy:Composable}. Core language for array fusion transformations where the fusion process is guaranteed not to increase the runtime of the program. 
\item On the duality of streams paper~\cite{Bernardy:Duality} mentions linear types.
\item You pull~\cite{Kay:YouPull}
\item Volcano DBMS one of the first to use abstract producers and iterator pattern. Its exchange operator is similar to our drainP.~\cite{Graefe:Volcano}
\end{itemize}


% Repa flow fills a sweet spot between the roles functional array library and analytic database. In terms of the programming model, a key feature of Repa Flow compared with Scoobi and Scalding is that the API carefully distinguishes between operators that run in constant space and those which do not. Systems based on map-reduce make implicit use of a \emph{shuffle} operator that distributes data between the compute nodes. The \emph{shuffle} operator sends data between the nodes in a data-dependent way, which can result in a skewed workload where most data is sent to a subset of nodes while the others are starved. When all source-level queries are converted into map-reduce jobs then there is no systematic way in which skew can be avoided. Taking inspiration from the work on synchronous data flow and Khan networks, we have arranged our API so that most operators execute without buffering. With Repa Flow it is easy to write programs where both buffering and data skew are avoided by construction, or admitted only in a controlled way.
