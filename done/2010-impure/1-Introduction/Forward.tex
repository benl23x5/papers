\section{A way forward}

Disciple allows destructive update and lazy evaluation to be present in the same language. We do this while preserving the overall structure of types, and while keeping most of the nice algebraic properties associated with purely functional languages. By preserving the structure of types we hope to avoid the refactoring exercises discussed earlier. We do not rule out support for state monads or $\iRef$ types, rather we desire a system which does not \emph{require} them to write most programs.

We use a type based mutability and effect analysis. The analysis determines which objects in the program might be destructively updated, and which are guaranteed to remain constant. Using this information, the compiler can perform optimisations on the pure parts of the program while leaving expressions with interfering computational effects in their original order. This strategy is similar to that taken by Tolmach~\cite{tolmach:optimizing-ml} though we use a System-F~\cite{reynolds:towards-a-theory-of-type-structure} style core language instead of a monadic one. The core language uses a witness passing mechanism to manage mutability and effect constraints, similar to that used to manage type equality constraints in System-Fc~\cite{sulzmann:system-Fc}. Although the extra mutability and effect information is visible in source types, it can usually be elided by the programmer, and is therefore not an undue burden.

The default evaluation method is call-by-value. This makes it easier to construct an efficient implementation on current hardware, as well as eliminating an important source of space leaks. The programmer may manually suspend function applications when desired, and the runtime system will automatically force them as needed. This is unlike library based implementations of laziness in languages such as O'Caml. These implementations require the use of explicit forcing functions, as well as changing the types of lazy values. 

We also use our analysis to detect when an object is guaranteed \emph{not} to be a thunk. Our implementation of lazy evaluation is likely to be slower than a natively lazy system such as GHC. However, non-lazy code should not suffer a substantial performance penalty compared with other default strict languages such as ML and C.

Our type system uses a type class based mechanism to attach purity, mutability, constancy, laziness and other constraints to data types. This allows functions to be polymorphic in those attributes and not require the overall structure of types to be changed. We also use this mechanism to detect when the combination of laziness and destructive update in the same program might give a result different to the call-by-value case. We flag these as type errors and assert that our language is still purely functional by Sabry's definition~\cite{sabry:purely}. Our language includes support for record types, and we use type directed field projections which permit field names to be in record-local scope. 

We would like for it to be possible \emph{and} practical to write efficient programs in our language. Finally, we would like it to be attractive to people who don't actually care that much about the philosophy of functional programming. We follow Steele and Sussman \cite{steele:lambda-ultimate-imperative}, and Knuth \cite{knuth:structured-programming} in that a language designer's emphasis should be on helping the programmer solve their particular problems. Our aim is not to separate language features into ``good'' and ``bad'', only to offer sharp tools in a hope they will be useful.
