%!TEX root = ../Main.tex

\clearpage
\section{Streams and Flows}

Our library is based around polarised streams. A stream is the usual list like structure which allows the next element to be taken from the front, but does not support random access of other elements. We imagine a stream as an array where the indexing dimension is time --- as each element is read it exists only for a moment, then is gone. In the library we manipulate stream endpoints rather than the streams themselves. The endpoints are polarised, meaning that we push (write) data in to stream sinks, but pull (read) data from stream sources. We name a \emph{bundle} several related streams a \emph{flow}. Typically, a flow consists of streams that carry separate partitions of a single large data set. Fig \ref{f:GenericFlows} shows the types we use to represent the the bundle of stream endpoints for an overall flow.

In the type @Sources i m e@, the @i@ parameter stands for type that indexes the individual streams, @m@ is a monadic constructor that sets the computational fabric, and @e@ is the type of elements pushed to or pulled from the endpoints. The paramters of the @Sinks@ constructor are similar. 

Mention conduit and pipes, manpiulates whole streams.

\begin{figure}
\begin{code}
data Sources i m e 
   = Sources { arity :: i
             , pull  :: i -> (e -> m ()) -> m () 
                                         -> m () }
data Sinks   i m e 
   = Sinks   { arity :: i
             , push  :: i -> e -> m ()
             , eject :: i -> m () }
\end{code}
\label{f:GenericFlows}
\caption{Generic Flow definitions and conversions}
\end{figure}

\begin{figure}
\begin{code}
zipWith_ii :: Monad m => (a -> b -> c)
           -> Sources i m a -> Sources i m b -> m (Sources i m c)
zipWith_ii f (Sources nA pullA) (Sources nB pullB)
 = return \$ Sources (min nA nB) pullC
 where  pullC i eatC ejectC
         = pullA i eatA ejectC
         where  eatA xA = pullB i eatB ejectC
                 where  eatB xB = eatC (f xA xB)

zipWith_io :: (Ord i, Monad m) => (a -> b -> c)
           -> Sinks i m c -> Sources i m a -> m (Sinks i m b)
zipWith_io f (Sinks nC pushC ejectC) (Sources nA pullA)
 = return \$ Sinks nB pushB ejectC
 where  nB = min nC nA
        pushB i xB 
         | i > nB       = return ()
         | otherwise    = pullA i eatA (ejectC i)
         where  eatA xA = pushC i (f xA xB)
\end{code}
\caption{Continuation style implementation of zipWith functions}
\end{figure}

\begin
{figure*}
\begin{code}
-- Conversion
fromList   :: i -> [a] -> m (Sources i m a)
toList1    :: i -> Sources i m a -> m [a]

fromLists  :: [[a]] -> m (Sources Int m a)
toLists    :: Sources Int m a -> m [[a]]

-- Computation
drainS     :: Sources i   m  a -> Sinks i   m  a -> m  ()
drainP     :: Sources Int IO a -> Sinks Int IO a -> IO ()

-- Mapping
map_i      :: (a -> b) -> Sources i m a  -> m (Sources i m b)
map_o      :: (b -> a) -> Sinks   i m b  -> m (Sinks   i m a)

zipWith_ii ::  (a -> b -> c) 
                  -> Sources i m a -> Sources i m b -> m (Sources i m c)
zipWith_io :: ... -> Sources i m a -> Sinks   i m c -> m (Sinks   i m b)
zipWith_oi :: ... -> Sinks   i m a -> Sources i m b -> m (Sinks   i m a)

-- Connection
dup_oo     ::        Sinks   i m a -> Sinks   i m a -> m (Sinks   i m a)
dup_io     ::        Sources i m a -> Sinks   i m a -> m (Sinks   i m a)
dup_oi     ::        Sinks   i m a -> Sources i m a -> m (Sinks   i m a)

connect_i  ::        Sources i m a -> m (Sources i m a, Sources i m a)

-- Projection
project_i  :: i ->   Sources i m a -> m (Sources () m a)
project_o  :: i ->   Sinks   i m a -> m (Sinks   () m a)

-- Funneling
funnel_i   ::        Sources i m a -> m (Sources () m a)
funnel_o   ::        Sinks  () m a -> m (Sinks   i  m a)

-- Elided constraints: (Monad m, States i m) => ...
\end{code}
\caption{Generic Flow operators}
\end{figure*}


